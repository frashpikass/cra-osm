#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sun Aug 28 16:23:00 2016

@author: Francesco Piazza
"""

# NOTE: the SRID of the input DB is 4326
# NOTE: the SRID of the output DB is 3857

### Imports
import ConfigParser
import math
import numpy as np
import os
import os.path
import scipy as sc
import scipy.cluster.hierarchy
import scipy.spatial.distance
import sys
import datetime
import time
from optparse import OptionParser
from pyspatialite import dbapi2 as db
from shutil import copyfile

### Global constants
CONFIG_DIR = "conf"
CONFIG_DEFAULT = "defaults.cfg"
GOODTAGS_DEFAULT = "goodtags.txt"
OUTDB_DEFAULT = "%s_%s_cra.sqlite"  # % (input_filename, username)
SRIDIN_DEFAULT = "4326"
SRIDOUT_DEFAULT = "3857"
GRID_DEFAULT = "1000"
DAYS_DEFAULT = "180"
TEMPDB_PATH = "temp.sqlite"

TIME_FORMAT = '%Y-%m-%dT%H:%M:%SZ'

EPSILON_DEFAULT = 0.0001
LIMITDISTANCE_DEFAULT = 5

### Error messages
ERROR = "ERROR! "
EXCEPTION_ERROR = "%s"
NO_INDB_SPECIFIED_ERROR = "No input database specified!"
NO_USERNAME_SPECIFIED_ERROR = "No username specified!"
NO_INDB_FOUND_ERROR = "No database '%s' found!"
USERNAME_NOT_FOUND_ERROR = "Username '%s' not found in input database!"



### Classes


# Class to research pet locations generated by Most Valuable Player users
class CRA:
    # Sublass to store the maximum boundaries of the analysis grid
    class Gridbounds:
        # Coordinates of upper left bound
        min_x = None
        min_y = None
        # Coordinates of lower right bound
        max_x = None
        max_y = None

        # Constructor for class Gridbounds
        def __init__(self, min_x, min_y, max_x, max_y):
            self.min_x = float(min_x)
            self.min_y = float(min_y)
            self.max_x = float(max_x)
            self.max_y = float(max_y)

    # List of input database table names from which points and users are gathered
    # Suggested names are "osm_nodes", "osm_ways", "osm_relations"
    tables = ["osm_nodes", "osm_relations", "osm_ways"]

    # Path to input database
    indb = None

    # Username to calculate CRA for
    username = None

    # Path to output database
    outdb = None

    # Size of the time window in days (int)
    days = None

    # Grid resolution in SRID units (float)
    grid = None

    # Gridbounds object that stores the maximum boundaries of the analysis grid
    gridbounds = None

    # Spatial Reference System Identifier (SRID) for the input database
    srid_in = None

    # Spatial Reference System Identifier (SRID) for the output database
    srid_out = None

    # List of tags that indicate good local knowledge of the area
    goodtags = None

    # epsilon to calculate the p value
    epsilon = None

    # how many cells it takes for the Shepard weight to reach epsilon for a certain point
    limitdistance = None


    # Constructor for class CRA
    def __init__(self, indb, username, outdb, days, grid, srid_in, srid_out, goodtags_filename,
                 epsilon, limitdistance):
        self.indb = indb
        self.username = username
        self.outdb = outdb
        self.days = int(days)
        self.grid = float(grid)
        self.srid_in = srid_in
        self.srid_out = srid_out
        self.epsilon = float(epsilon)
        self.limitdistance = int(limitdistance)

        self.checkDB()
        self.initdb()
        self.initGoodTags(goodtags_filename)
        self.initGridbounds()

    # Checks for the existance of input, output and temp database (for optimization)
    # Also checks for username in indb
    def checkDB(self):
        print("> Checking input database...")
        if os.path.isfile(self.indb):
            print("Input database '%s' OK" % self.indb)
            print("> Checking for old output database...")
            if os.path.isfile(self.outdb):
                print("Removing stale output database '%s'..." % self.outdb)
                os.remove(self.outdb)
            else:
                print("No stale output database found.")
            print("> Checking for temporary database '%s'..." % TEMPDB_PATH)
            if os.path.isfile(TEMPDB_PATH):
                print("Temporary DB is OK")
            else:
                print("> No temporary database found. Initialization...")
                self.initTempDB()

            # Checking for username in indb
            print("> Checking the existance of username '%s' in the input database..." % self.username)
            if self.usernameExists(self.username):
                print("Username '%s' found!" % self.username)
            else:
                cliError(USERNAME_NOT_FOUND_ERROR % self.username)

        else:
            cliError(NO_INDB_FOUND_ERROR % self.indb)

    # Initializes temporary output DB
    def initTempDB(self):
        cur = db.connect(TEMPDB_PATH)
        rs = cur.execute('SELECT sqlite_version(), spatialite_version()')
        for row in rs:
            msg = "> System dependencies are OK. SQLite v%s Spatialite v%s" % (row[0], row[1])
            print msg
        print("> Database setup in progress, it might take a few minutes...")

        # Initialize the tempdb for spatial operations
        sql = 'SELECT InitSpatialMetadata()'
        cur.execute(sql)

        # Table creation queries for outdb

        # Create the points table
        sql = '''CREATE TABLE points (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user STRING,
                    timestamp TEXT,
                    tag TEXT
                    );'''
        cur.execute(sql)

        sql = '''SELECT AddGeometryColumn('points',
                    'geometry', %s, 'POINT', 'XY');''' % self.srid_out
        cur.execute(sql)

        # creating the grid table
        sql = '''CREATE TABLE grid (
                id INTEGER PRIMARY KEY AUTOINCREMENT)'''
        cur.execute(sql)

        sql = '''SELECT AddGeometryColumn('grid',
                 'geometry', %s, 'POLYGON', 'XY')''' % self.srid_out
        cur.execute(sql)

        # creating the usersgrid table
        sql = '''CREATE TABLE usersgrid (
                    grid_id INTEGER PRIMARY KEY,
                    node_count INTEGER,
                    timestamp_max TEXT,
                    timestamp_min TEXT,
                    activity INTEGER,
                    goodtags INTEGER,
                    reliability REAL default 0,
                    FOREIGN KEY (grid_id) REFERENCES grid(id)
                    );'''
        cur.execute(sql)

        sql = '''SELECT AddGeometryColumn('usersgrid',
                    'center', %s, 'POINT', 'XY');''' % self.srid_out
        cur.execute(sql)

        # Initialize spatial indexes for all tables in tempDB
        self.initSpatialIndex(TEMPDB_PATH)

        rs.close()
        cur.commit()
        cur.close()
        print "Temporary database setup completed!"

    # Initializes both input and output db so that they're ready to update and query
    def initdb(self):
        print("> Initializing all databases...")

        # Setting up outdb (quick copy of tempdb)
        print("> Copying temporary db '%s' to output db '%s'..." % (TEMPDB_PATH, self.outdb))
        copyfile(TEMPDB_PATH, self.outdb)

        # Setting up indb index
        self.initSpatialIndex(self.indb)

    # Checks for the existance of a username
    def usernameExists(self, username):
        cur = db.connect(self.indb)

        sql = '''
        SELECT user FROM osm_nodes WHERE user = '%s'
        UNION
        SELECT user FROM osm_relations WHERE user = '%s'
        UNION
        SELECT user FROM osm_ways WHERE user = '%s'
        ''' % (username, username, username)

        rs = cur.execute(sql)

        if rs.fetchall():
            return True
        else:
            return False


    # Initializes the spatial index of given database (necessary for spatialite RTree queries on database)
    def initSpatialIndex(self, database):
        cur = db.connect(database)
        rs = cur.execute('SELECT * FROM geometry_columns')
        print("> Initializing Spatial Index for db %s..." % database)

        for row in rs:
            # Check if there's already a Spatial Index for the current table of current db
            if row[5] != 0:
                print("\tSpatial Index for table '%s' already ok!" % (row[0]))
            else:
                print("\tInitializing Spatial Index for table '%s', please wait..." % (row[0]))
                cur.execute("SELECT CreateSpatialIndex('%s', '%s');" % (row[0], row[1]))
                print("\tSpatial Index initialized!")
        rs.close()
        cur.close()

    # Gets good tags from a multiline text file, sanitize them, init goodtags both here and in
    # output db for query optimization
    def initGoodTags(self, filename):
        print("> Initializing good tags...")
        try:
            f = open(filename, 'r')
            self.goodtags = [item.strip() for item in f.readlines()]
            f.close()

            dbs = [self.outdb]

            for dbpath in dbs:
                print("Initializing table goodtags of '%s'..." % dbpath)
                cur = db.connect(dbpath)
                # Check if there's an old version of the goodtags table and eventually drop it
                rs = cur.execute("SELECT sql FROM sqlite_master WHERE type = 'table' AND name = 'goodtags'")
                if rs.fetchall():
                    cur.execute("DROP TABLE goodtags")
                    print("Stale table goodtags of '%s' dropped" % dbpath)

                # Create and populate the goodtags table
                cur.execute("CREATE TABLE goodtags (k TEXT PRIMARY KEY)")
                for tag in self.goodtags:
                    sql = "INSERT INTO goodtags (k) VALUES (\'%s\')" % tag
                    cur.execute(sql)

                cur.commit()
                cur.close()
                print("Table goodtags of '%s' created and populated!" % dbpath)

        except OSError, e:
            cliError(EXCEPTION_ERROR % e)

    # Initializes the gridbounds for later operations
    def initGridbounds(self):
        print "> Initializing grid boundaries..."

        # Setting up a safety offset to draw a grid that's bigger than the map examined
        offset = self.limitdistance*self.grid

        indb = db.connect(self.indb)
        incur = indb.cursor()

        # Gather the extreme boundaries of our node map (from indb), supposedly with INDB srid
        sql = '''
        SELECT
            Min(MbrMinX(osm_nodes.geometry)) AS min_x,
            Min(MbrMinY(osm_nodes.geometry)) AS min_y,
            Max(MbrMaxX(osm_nodes.geometry)) AS max_x,
            Max(MbrMaxY(osm_nodes.geometry)) AS max_y
        FROM osm_nodes;
        '''
        rs = incur.execute(sql).fetchone()
        minx = rs[0]
        miny = rs[1]
        maxx = rs[2]
        maxy = rs[3]

        # Transform the boundaries in the new SRID for outdb
        sql = 'SELECT ST_X(transform(MakePoint(%s,%s,%s),%s)),' % (minx, miny, self.srid_in, self.srid_out)
        sql += 'ST_Y(transform(MakePoint(%s,%s,%s),%s)),' % (minx, miny, self.srid_in, self.srid_out)
        sql += 'ST_X(transform(MakePoint(%s,%s,%s),%s)),' % (maxx, maxy, self.srid_in, self.srid_out)
        sql += 'ST_Y(transform(MakePoint(%s,%s,%s),%s));''' % (maxx, maxy, self.srid_in, self.srid_out)
        rs = incur.execute(sql).fetchone()

        # Initialize grid boundaries
        self.gridbounds = self.Gridbounds(rs[0] - offset, rs[1] - offset, rs[2] + offset, rs[3] + offset)

        # Close connections
        incur.close()
        indb.close()

    # Inserts a selection of nodes created by username into the points table of outdb
    def insertptlnodes(self):
        print "> Searching the input database for nodes created by user '%s'..." % self.username
        indb = db.connect(self.indb)
        incur = indb.cursor()
        dbout = db.connect(self.outdb)
        outcur = dbout.cursor()
        for table in self.tables:
            sql = None

            if table == 'osm_nodes':
                # The following query has the purpose
                # of returning all nodes made by username
                # along with their timestamp, their tag and the WKT of their Geometry
                sql = '''
                SELECT
                    n.user AS user, n.timestamp AS timestamp, t.k AS tag,
                    AsText( Transform(n.Geometry, %s) ) AS GeometryWKT
                FROM osm_nodes AS n, osm_node_tags AS t
                WHERE n.user = '%s' AND n.node_id = t.node_id;
                ''' % (self.srid_out, self.username)

            elif table == 'osm_ways':
                # The following query returns the WKT of the geometry of every node which is
                # part of a way created by username, along with the name of the user who took care of the way,
                # the timestamp that indicates when the way was edited for the last time,
                # and the tag that the way eventually attaches to such node
                sql = '''
                SELECT
                    q.user AS user, q.timestamp AS timestamp, t.k AS tag,
                    AsText( Transform(q.Geometry, %s) ) AS GeometryWKT
                FROM (
                    SELECT w.user, w.timestamp, r.way_id, r.sub, r.node_id, n.Geometry
                    FROM osm_ways AS w, osm_way_refs AS r, osm_nodes AS n
                    WHERE
                        w.user = '%s'
                        AND w.way_id = r.way_id
                        AND n.node_id = r.node_id
                ) AS q
                LEFT JOIN osm_way_tags AS t
                ON (q.way_id=t.way_id AND q.sub=t.sub);
                ''' % (self.srid_out, self.username)
            elif table == 'osm_relations':
                # For maximum readability and efficiency, this query creates a temp table called user_rels
                # containing all relations created by username, along with the timestamp, the relation tag,
                # the relation id, the type and the reference of every object
                # a relation is bound to.
                # The table is automatically dropped as the connection is closed.

                sql_temp = '''
                CREATE TEMP TABLE user_rels AS
                SELECT
                    q.user AS user, q.timestamp AS timestamp, t.k AS tag,
                    q.type AS type, q.ref AS ref
                FROM (
                    SELECT r.user, r.timestamp, refs.rel_id, refs.type, refs.ref, refs.sub
                    FROM osm_relations AS r, osm_relation_refs AS refs
                    WHERE r.user = '%s' AND refs.rel_id=r.rel_id
                ) AS q
                LEFT JOIN osm_relation_tags AS t
                ON (q.rel_id=t.rel_id AND q.sub=t.sub);
                ''' % self.username
                incur.execute(sql_temp)

                # The following query returns the correctly contextualized geometry of every node which is
                # part of a relation created by username, together with the name of the user who took care of
                # the relation, the timestamp of the last edit and the tag associated to the relation
                # the node is part of.
                sql = '''
                SELECT user, timestamp, tag, AsText( Transform(Geometry, %s) ) AS GeometryWKT
                FROM(
                    SELECT
                        r.user AS user, r.timestamp AS timestamp, r.tag AS tag,
                        n.Geometry AS Geometry
                    FROM user_rels AS r, osm_nodes AS n
                    WHERE r.type='N' AND r.ref=n.node_id

                    UNION

                    SELECT
                        r.user AS user, r.timestamp AS timestamp, r.tag AS tag,
                        n.Geometry AS Geometry
                    FROM user_rels AS r, osm_way_refs AS w, osm_nodes AS n
                    WHERE r.type='W' AND r.ref=w.way_id AND w.node_id=n.node_id
                );
                ''' % self.srid_out

            # Insert our precious data into the outdb
            rs = incur.execute(sql)
            rowcount = 0
            for r in rs:
                # r[0] is user
                # r[1] is timestamp
                # r[2] is tag
                # r[3] is GeometryWKT

                p = "GeomFromText(\'%s\',%s)" % (r[3], self.srid_out)
                sql = "INSERT INTO points (user, timestamp, tag, geometry)"
                sql += "VALUES (?,?,?,%s);" % p
                outcur.execute(sql, (r[0], r[1], r[2]))
                rowcount += 1
            dbout.commit()

            print("%d nodes imported from table %s" % (rowcount, table))

        # Finalize and close connections
        outcur.close()
        dbout.close()
        incur.close()
        indb.close()

    # Creates a grid shaped geometrical structure in the outdb for further operations
    def creategrid(self):
        print "> Creating a grid lattice in the output database..."

        # Connect to the output db
        dbout = db.connect(self.outdb)
        outcur = dbout.cursor()

        # Define the boundaries of the first square of the grid
        stepminx = self.gridbounds.min_x
        stepmaxx = self.gridbounds.min_x + self.grid
        stepminy = self.gridbounds.min_y
        stepmaxy = self.gridbounds.min_y + self.grid

        # Grid creation loop
        while True:
            # Create a polygon using the boundaries of a square on the grid and insert it in the 'grid' table in outdb
            p = "GeomFromText('POLYGON(("
            p += "%f %f, " % (stepminx, stepminy)
            p += "%f %f, " % (stepmaxx, stepminy)
            p += "%f %f, " % (stepmaxx, stepmaxy)
            p += "%f %f, " % (stepminx, stepmaxy)
            p += "%f %f" % (stepminx, stepminy)
            p += "))',%s)" % self.srid_out
            sql = "INSERT INTO grid (geometry) "
            sql += "VALUES (%s);" % p
            outcur.execute(sql)

            # Update the boundaries
            if stepmaxx < self.gridbounds.max_x:
                # Step forward one column
                stepminx = stepmaxx
                stepmaxx += self.grid
            else:
                # Step forward one row
                stepminx = self.gridbounds.min_x
                stepmaxx = self.gridbounds.min_x + self.grid
                stepminy += self.grid
                stepmaxy += self.grid

                # Check if our cursor is out of all maximum boundaries
                if stepmaxy > self.gridbounds.max_y:
                    # Stop adding squares to the grid
                    break

        # Finalize changes and close connections
        dbout.commit()
        outcur.close()
        dbout.close()

    # Analyzes user contributions to get reliability approximations for each grid cell
    def createusersgrid(self):
        print "> Creating user contribution grids..."

        # Connect to the output db
        dbout = db.connect(self.outdb)
        outcur = dbout.cursor()
        cursor = dbout.cursor()

        # This query gets all the data needed to populate table usersgrid, except for the reliability
        # which will be calculated as a function of this data.
        # For user username, for each cell in the grid, this query gathers
        # 0) the id number of the cell
        # 1) the number of points created by username
        # 2) the youngest timestamp of a point in the cell
        # 3) the oldest timestamp of a point in the cell
        # 4) the difference between the two expressed in days (referred to as "activity")
        # 5) the number of points in the cell which are described by a good tag (referred to as "goodtags")
        # 6) the Well Known Text (WKT) describing the coordinates of the centroid of the cell
        sql = '''
        SELECT
            q1.gid, q1.node_count, q1.timestamp_max, q1.timestamp_min,
            q1.activity, q2.goodtags_count, AsWKT(Centroid(q1.geometry)) AS centerWKT
        FROM(
            SELECT
                g.id AS gid, count(p.id) AS node_count,
                max(p.timestamp) AS timestamp_max, min(p.timestamp) AS timestamp_min,
                ( Round(JulianDay(max(p.timestamp))) - Round(JulianDay(min(p.timestamp))) ) AS activity,
                g.geometry AS geometry

            FROM grid AS g, points AS p

            WHERE p.ROWID IN (
                SELECT ROWID
                FROM SpatialIndex
                WHERE f_table_name = 'points'
                AND search_frame = g.geometry
            )
            GROUP BY gid
        ) AS q1
        LEFT JOIN (
            SELECT grid.id AS gid, COUNT(points.id) AS goodtags_count
            FROM grid, points
            WHERE points.ROWID IN (
                SELECT ROWID
                FROM SpatialIndex
                WHERE f_table_name = 'points'
                AND search_frame = grid.geometry
            ) AND points.tag IN goodtags
            GROUP BY gid
        ) AS q2
        ON (q1.gid = q2.gid);
        '''
        rs = cursor.execute(sql)

        # Expected structure of resultset
        # r[0] is grid_id
        # r[1] is node_count
        # r[2] is timestamp_max
        # r[3] is timestamp_min
        # r[4] is activity
        # r[5] is goodtags
        # r[6] is centerWKT

        # Data entry
        for r in rs:
            if r is not None:
                # Fetching values from points table
                grid_id = int(r[0])
                node_count = int(r[1])
                timestamp_max = r[2]
                timestamp_min = r[3]
                activity = r[4]     # days of user activity in the cell
                goodtags = r[5]     # number of nodes described by goodtags in the cell
                centerWKT = r[6]    # text representation of cell centroid

                # Sanitizing null values...
                if activity is None:
                    activity = 0
                else:
                    activity = int(activity)

                if goodtags is None:
                    goodtags = 0
                else:
                    goodtags = int(goodtags)

                # Approximating reliability
                reliability = self.reliabilityApproximation(node_count, timestamp_max, activity, goodtags)

                # If the cell contains valuable data, proceed with data entry
                if reliability > 0:
                    p = "GeomFromText(\'%s\',%s)" % (centerWKT, self.srid_out)
                    sql = '''
                    INSERT INTO usersgrid
                    (
                        grid_id, node_count, timestamp_max, timestamp_min,
                        activity, goodtags, center, reliability
                    )'''
                    sql += '''VALUES
                    (%d,%d,'%s','%s',%d,%d,%s,%f);''' % (grid_id, node_count, timestamp_max,
                                                         timestamp_min, activity, goodtags,
                                                         p, reliability)
                    outcur.execute(sql)

        # Finalize changes and close connections
        dbout.commit()
        cursor.close()
        outcur.close()
        dbout.close()

    # Estimates reliability for a usergrid cell from point parameters that determine
    # pet location quality
    def reliabilityApproximation(self, node_count, timestamp_max, activity, goodtags):
        reliability = 0.0

        now = datetime.datetime.today()
        then = datetime.datetime.strptime(timestamp_max, TIME_FORMAT)
        age = (now-then).days

        if activity >= self.days:
            if goodtags >= 1:
                if age < self.days:
                    reliability = 1
                else:
                    reliability = 0.75
            else:
                if age < self.days:
                    reliability = 0.5
                else:
                    reliability = 0.25

        return reliability

    # Gets the best Shepard p value for this problem
    def pShepard(self):
        return - math.log(self.epsilon, self.limitdistance*self.grid)


# END OF CLASS CRA

### Script functions

# Interfaces the main() method with the model
def execCRA(cmd):
    # Parameters which can be found in the config file
    goodtags_filename = None
    outdb = None
    srid_in = None
    srid_out = None
    grid = None
    days = None
    epsilon = None
    limitdistance = None

    # Parameters which are required as inputs
    indb = None
    username = None

    # If there's no config file, make it
    makeConfig(replace=False)

    # Try to set up defaults from the config file...
    try:
        # Parse options from the config file
        parser = ConfigParser.ConfigParser(allow_no_value=True)
        parser.readfp(open(CONFIG_DIR + os.path.sep + CONFIG_DEFAULT))

        goodtags_filename = parser.get("goodtags", "file")
        srid_in = parser.get("config", "srid_in")
        srid_out = parser.get("config", "srid_out")
        grid = parser.get("config", "grid")
        days = parser.get("config", "days")
        epsilon = parser.get("idw", "epsilon")
        limitdistance = parser.get("idw", "limitdistance")

        if parser.has_option("outdb","file"):
            outdb = parser.get("outdb", "file")

    except ConfigParser.NoOptionError, e:
        cliError(EXCEPTION_ERROR % e)

    # Parse options from the input args
    # Mandatory options
    if cmd.input:
        indb = cmd.input
    else:
        cliError(NO_INDB_SPECIFIED_ERROR)

    if cmd.username:
        username = cmd.username
    else:
        cliError(NO_USERNAME_SPECIFIED_ERROR)

    # Optional parameters
    if cmd.tags:
        goodtags_filename = cmd.tags
    if cmd.output:
        outdb = cmd.output
    if cmd.sridin:
        srid_in = cmd.sridin
    if cmd.sridout:
        srid_out = cmd.sridout
    if cmd.grid:
        grid = cmd.grid
    if cmd.days:
        days = cmd.days
    if cmd.epsilon:
        epsilon = cmd.epsilon
    if cmd.limitdistance:
        limitdistance = cmd.limitdistance

    # Default parameters
    if goodtags_filename is None:
        goodtags_filename = GOODTAGS_DEFAULT
    if outdb is None:
        outdb = OUTDB_DEFAULT % (indb.rsplit(".", 1)[0], username)
    if srid_in is None:
        srid_in = SRIDIN_DEFAULT
    if srid_out is None:
        srid_out = SRIDOUT_DEFAULT
    if days is None:
        days = DAYS_DEFAULT
    if epsilon is None:
        epsilon = EPSILON_DEFAULT
    if limitdistance is None:
        limitdistance = LIMITDISTANCE_DEFAULT

    print("ExecCRA: %s %s %s %s %s %s %s %s %s %s" % (days, srid_in, srid_out, indb, username,
                                                outdb, grid, goodtags_filename, epsilon,
                                                      limitdistance))  # debug

    # Initialize the CRA object, input and output databases
    mu = CRA(indb, username, outdb, days, grid, srid_in, srid_out, goodtags_filename,
             epsilon, limitdistance)

    # Initialize the DBs
    # mu.initdb()
    # Create a grid in the outer DB (mu.grid = length of a cell side)
    mu.creategrid()

    # Insert the list of nodes created by username into the outdb points table
    mu.insertptlnodes()

    # Place user contributions into each grid cell and approximate cell reliability
    mu.createusersgrid()

    # Calculate the Shepard p value for the raster representation
    p = mu.pShepard()

    print("All operations were completed with success!")
    print("Enjoy your data in %s - Import it in QGIS to visualize it!" % mu.outdb)
    print(
            "Plot an interpolation raster made by an IDW interpolation algorithm with " +
            "\n\t - a grid cell size of %d by %d" % (mu.grid, mu.grid) +
            "\n\t - a Shepard p value of %f" % (p)
          )
    print("(Use \'spatialite_osm_map\' to set up the undelying map from the original osm file)")


# Creates the config file
# If the replace option is True, it will replace existing config files
def makeConfig(replace = False):
    # Set config file path
    configpath = CONFIG_DIR + os.path.sep + CONFIG_DEFAULT

    # If the directory doesn't exist, make it
    if not os.path.exists(CONFIG_DIR):
        os.makedirs(CONFIG_DIR)

    # If the old config exists and replace is True, remove the old config file
    if os.path.isfile(configpath):
        if replace is True:
            os.remove(configpath)
        else: return

    # Create a new config file
    try:
        f = open(configpath, 'w+')

        f.write("[config]\n")
        f.write("srid_in=%s\n" % (SRIDIN_DEFAULT))
        f.write("srid_out=%s\n" % (SRIDOUT_DEFAULT))
        f.write("grid=%s\n" % (GRID_DEFAULT))
        f.write("days=%s\n" % (DAYS_DEFAULT))
        f.write("[goodtags]\n")
        f.write("file=%s\n" % (CONFIG_DIR + os.path.sep + GOODTAGS_DEFAULT))
        f.write("[outdb]\n")
        f.write("#file=output.sqlite\n")
        f.write("[idw]\n")
        f.write("epsilon=%s\n" % EPSILON_DEFAULT)
        f.write("limitdistance=%s\n" % LIMITDISTANCE_DEFAULT)

        f.close()
    except OSError, e:
        cliError(EXCEPTION_ERROR % e)

# CLI user interface
def main():
    usage = "usage: %prog [options]"
    parser = OptionParser(usage)

    parser.add_option("-i", "--input", action="store", dest="input",
                      help="input sqlite/spatialite database file (REQUIRED)")
    parser.add_option("-u", "--username", action="store", dest="username",
                      help="username to calculate the affidability map for (REQUIRED)")
    parser.add_option("-c", "--create", action="store_true", dest="create",
                      help="create a new configuration file template (and overwrite the existing one) *",
                      default=False)
    parser.add_option("-o", "--output", action="store", dest="output",
                      help="output sqlite/spatialite database filename *")
    parser.add_option("-s", "--sridin", action="store", dest="sridin",
                      help="metric (SRID) for the input database *")
    parser.add_option("-S", "--sridout", action="store", dest="sridout",
                      help="metric (SRID) for the output database *")
    parser.add_option("-g", "--grid", action="store", dest="grid", help="grid size expressed in SRID unit *")
    parser.add_option("-d", "--days", action="store", dest="days", help="time window for analysis expressed in days *")
    parser.add_option("-t", "--tags", action="store", dest="tags",
                      help="txt file with the list of good tags to consider *")
    parser.add_option("-e", "--epsilon", action="store", dest="epsilon",
                      help="arbitrarily small positive quantity that indicates how much of "
                           "the Shepard weight is left after a limit distance *")
    parser.add_option("-l", "--limitdistance", action="store", dest="limitdistance",
                      help="limit distance (expressed in number of grid cells)"
                           "after which the Shepard weight for affidability is epsilon *")

    (options, args) = parser.parse_args()
    if not options.create:
        # Mandatory options are -i, -u
        if options.input is not None and options.username is not None:
            execCRA(options)
        else:
            parser.print_help()
            print("* not required, eventually overrides defaults from the config file")
            print("Remember to use \'spatialite_osm_raw\' on the original osm file "
                  "to get an sqlite input file for this script!")
            sys.exit(0)
    else:
        makeConfig(replace=True)
        print("Configuration file regenerated!")

# CLI Error function
# Displays a message and stops the script with exit code 2
def cliError(message):
    print(ERROR + message)
    sys.exit(2)

# If the script is run from command line, call the main function
# It's showtime!
if __name__ == "__main__":
    main()
